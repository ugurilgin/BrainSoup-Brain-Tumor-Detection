from cv2 import  cv2
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import timeit
from PIL import Image
from keras.models import load_model
from matplotlib.pyplot import imshow
import numpy as np
import imutils
from sklearn.metrics import confusion_matrix
import itertools
import h5py


class TumorExtractor:
  def __init__(self,filename,outname):
    self.IMG_SIZE = (224,224)
    self.filename=filename
    self.outname=outname
 
  def cropImgs(self,setName, add_pixels_value=0):
    """
    Finds the extreme points on the image and crops the rectangular out of them
    """
    setNew = []
    for img in setName:
        gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
        gray = cv2.GaussianBlur(gray, (5, 5), 0)

        # threshold the image, then perform a series of erosions +
        # dilations to remove any small regions of noise
        thresh = cv2.threshold(gray, 45, 255, cv2.THRESH_BINARY)[1]
        thresh = cv2.erode(thresh, None, iterations=2)
        thresh = cv2.dilate(thresh, None, iterations=2)

        # find contours in thresholded image, then grab the largest one
        cnts = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        cnts = imutils.grab_contours(cnts)
        c = max(cnts, key=cv2.contourArea)

        # find the extreme points
        extLeft = tuple(c[c[:, :, 0].argmin()][0])
        extRight = tuple(c[c[:, :, 0].argmax()][0])
        extTop = tuple(c[c[:, :, 1].argmin()][0])
        extBot = tuple(c[c[:, :, 1].argmax()][0])

        ADD_PIXELS = add_pixels_value
        newImg = img[extTop[1]-ADD_PIXELS:extBot[1]+ADD_PIXELS, extLeft[0]-ADD_PIXELS:extRight[0]+ADD_PIXELS].copy()
        setNew.append(newImg)

    return np.array(setNew)
 
  def preprocessImgs(self,setName, imgSize):
    """
    Resize and apply VGG-15 preprocessing
    """
    setNew = []
    for img in setName:
        img = cv2.resize(
            img,
            dsize=imgSize,
            interpolation=cv2.INTER_CUBIC
        )
        setNew.append(img)
       
    return np.array(setNew),img

  
  
  def predict(self):
    
    model1 = load_model('model/VGG_model.h5') 
    #prediction = model1.predict([self.prepare(file)])
    img = cv2.imread(self.filename, cv2.IMREAD_COLOR)  
    testimg=[]
    testimg.append(img)  
    crop=self.cropImgs(testimg)
    x,image=self.preprocessImgs(crop,self.IMG_SIZE)
    #x=new_array.reshape(-1, self.IMG_SIZE, self.IMG_SIZE, 1)
    answ = model1.predict_classes(x)
   
    if (answ>=0.5):
      output="Pozitif"
      self.tumorSegmentation(image,0,"static/uploads/output/yes/"+self.outname+".jpg")   
    elif (answ<0.5):
      output="Negatif"
      self.tumorSegmentation(image,0,"static/uploads/output/no/"+self.outname+".jpg")
    return output

  def autoCanny(self,image, sigma=0.33):
    # compute the median of the single channel pixel intensities
    v = np.median(image)
    # apply automatic Canny edge detection using the computed median
    lower = int(max(0, (1.0 - sigma) * v))
    upper = int(min(255, (1.0 + sigma) * v))
    edged = cv2.Canny(image, lower, upper)
      # return the edged image
    return edged

  def tumorSegmentation(self,image,result,savepath):
    #image = image
    
    dim=(image.shape[1],image.shape[0])
    
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY, 0.7)
    (T, thresh) = cv2.threshold(gray, 155, 255, cv2.THRESH_BINARY)
    (T, threshInv) = cv2.threshold(gray, 155, 255, cv2.THRESH_BINARY_INV)
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (10, 5))
    closed = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel)
    closed = cv2.erode(closed, None, iterations = 14)
    closed = cv2.dilate(closed, None, iterations = 13)
    ret,mask = cv2.threshold(closed, 155, 255, cv2.THRESH_BINARY) 
    #apply AND operation on image and mask generated by thrresholding
    final = cv2.bitwise_and(image,image,mask = mask) 
    #plot the result
    
    canny = self.autoCanny(closed)
    (cnts, _) = cv2.findContours(canny.copy(), cv2.RETR_EXTERNAL,
    cv2.CHAIN_APPROX_SIMPLE)

    image = cv2.applyColorMap(image, cv2.COLORMAP_INFERNO)
    if (result==1):
      #cv2.drawContours(image, cnts, -1, (0, 128, 0), 2)
      image=cv2.applyColorMap(image, cv2.COLORMAP_INFERNO)
      cv2.imwrite(savepath, image)
    else:
      image=cv2.applyColorMap(image, cv2.COLORMAP_INFERNO)
      cv2.imwrite(savepath, image)



  






















 